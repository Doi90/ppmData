% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ppmdata.R
\name{ppmData}
\alias{ppmData}
\title{Create a point process quadrature scheme for spatial modelling.}
\usage{
ppmData(
  npoints = 10000,
  presences = NULL,
  window = NULL,
  covariates = NULL,
  coord = c("X", "Y"),
  mc.cores = parallel::detectCores() - 1,
  quasirandom.samples = NULL
)
}
\arguments{
\item{npoints}{The number of quadrature points to generate.}

\item{presences}{a matrix, dataframe or SpatialPoints object giving the
coordinates of each species' presence in (should be a matrix of nsites * 3)
with the three columns being c("X","Y","SpeciesID"), where X is longitude,
Y is latitude and SpeciesID is factor which assoicates each occurence to a
species. If presences parameter is NULL then ppmDat will return the
quadrature scheme without presences.}

\item{window}{a raster object giving the area over which to generate
background points. NA cells are ignored and masked out of returned data.
If ignored, a rectangle defining the extent of \code{presences} will be used.}

\item{covariates}{A raster object containing covariates for modelling the
point process (best use a Raster stack or Raster brick).}

\item{coord}{is the name of site coordinates. The default is c('X','Y').}

\item{mc.cores}{The number of cores to use in the processing. default is
parallel::detectCores()-1}

\item{quasirandom.samples}{This set the total number of samples to consider
in the BAS step (rejection sampling). The default is 10000, which means that
10000 halton numbers are drawn and then thinned according to the inclusion
probabilities. You will need to increase the number of samples if selecting
a large number of quadrature points. The more quasirandomSample selected the
slower the quasirandom quadrature scheme will be.}
}
\description{
This package is a way to efficiently generate a quasirandom set
of background points for presence-only modelling of single or multiple
respones. The package was set up to model muliple species presence-only
datasets, but could be used for an point process spatial modelling.
Quasirandom points are a nice alternative to pseudorandom samples, this is
because we can generate a quasirandom sample across and areal region
(X and Y coordinates), but we can also extend the dimensions of the
quasirandom sample to a N-dimensional hypervolume, which will allow users to
effectively sample the spatial and environmental space. This in turn should
reduce autocorrelation in quadrature scheme. The weight of each quadrature
point is calculated using Dirichlet (Voronoi) Tessellation as provided from
the \link[deldir]{deldir} function.
}
\details{
The approach uses quasi-random sampling to generate a quadrature
scheme based (e.g Berman & Turner 1992; Warton & Shepard 2010;
Foster et al, 2017). The weights each quasi-random point in the quadrature
scheme is calculated using a dirichlet tesselation (Turner 2020). To improve
comptational efficiency \link[deldir]{deldir} funcion for a large number of
of quadrature points, we set up an approach which breaks up the problem into
manageable sub-windows. We do this by keeping each deldir call to less that
5000 points (which appears to be the point where the algorithm slowes
noticibly). To avoid edge effect (large areas on the edges of sub-areas),
we rotate the subregions three times, the first two use a the nearest largest
prime number closest to total number of points (presences+quadrature points)
divided by 5000, which allows us to rotate the windon on the x and y axis
with an subsetable number of subwindows. We then caculate a third set of sub-
windows using a even set of squares. We then take the median weight across
all weight calculated for each point. We then can calculate this in parallel
for each species to make it computationlly more efficient.
}
\examples{
\dontrun{
library(ppmData)
library(raster)
path <- system.file("extdata", package = "ppmData")
lst <- list.files(path=path,pattern='*.tif',full.names = TRUE)
preds <- stack(lst)
window <- preds[[1]]
presences <- snails
bkgrid <- ppmData(npoints = 1000, presences=presences, window = window, covariates = preds)}
}
