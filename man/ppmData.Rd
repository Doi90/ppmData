% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/package.R, R/ppm_data.R
\docType{package}
\name{ppmData}
\alias{ppmData}
\title{package file}
\usage{
ppmData(
  presences,
  window = NULL,
  covariates = NULL,
  npoints = NULL,
  coord = c("X", "Y"),
  species.id = "SpeciesID",
  quad.method = c("quasi.random", "pseudo.random", "grid"),
  interpolation = c("simple", "bilinear"),
  unit = c("geo", "m", "km", "ha"),
  control = list()
)
}
\arguments{
\item{presences}{a three column matrix or data.frame object giving the
coordinates of each species' presence in (should be a matrix of nsites * 3)
with the three columns being c("X","Y","SpeciesID"), where X is longitude,
Y is latitude and SpeciesID is a factor which associated each occurrence to a
species.}

\item{window}{SpatRaster a raster object giving the region where to generate
the quadrature scheme. Windows with NA cells are ignored and masked out of returned data.
If NULL, a rectangle bounding the extent of \code{presences} will be used as
the default window.}

\item{covariates}{SpatRaster A terra raster object containing covariates for modelling
the point process. These layers should match the resolution and extent of the window
provided. If NULL, only the coordinates of the presences and quadrature
points are returned for the ppmData object.}

\item{npoints}{Integer The number of quadrature points to generate. If NULL, the
number of quadrature points is calculated based on linear scaling. In
reality, the number of quadrature points needed to approximate the
log-likelihood function will depend on the data and likelihood function
being approximated. Typically, the more quadrature the better the estimate,
but there is a trade off between computational efficiency and accuracy.
See Warton & Shepard (2010) or Renner et al., 2015 for useful discussions
on the location and number of quadrature points required to converge a
ppm likelihood.}

\item{coord}{Character These are the users name of site coordinates. The default is c('X','Y').
This should match the name of the coordinates in the presences data set.}

\item{species.id}{Character This is the column name of the species ID in the presences data set.
The default is "SpeciesID". But this should be changed to match the user's data.}

\item{quad.method}{Character The quadrature generation method. Default is "quasi.random" for
quasi-random, "pseudo.random" for pseudo-random (regular random) and "grid" for
a regular grid at a set resolution (with respect to the original window resolution).}

\item{interpolation}{Character The interpolation method to use when extracting
covariate data at a presence or quadrature location. Default is "bilinear", can also use "simple", this is based
on the terra package  \code{\link[terra]{extract}}.}

\item{unit}{Character The type of area to return. The default is "geo" and
returns the area based on the euclidean distance between geographic
coordinates. This will default to the values of the raster and presence
coordinate system. Alternatively, meters squared "m", kilometers squared "km", or hectares "ha" can be used.}

\item{control}{list A list of control parameters for using ppmData. See
details for uses of control parameters.}
}
\description{
ppmData is a package for setting up quadrature to implement
spatial Poisson Point process models and extensions.

This package is a way to efficiently generate a quasi-random set
of background points for presence-only modelling of single or multiple
responses. The package was set up to model multiple species presence-only
data sets, but could be used for an spatial point process modelling.
Quasi-random points are a nice alternative to pseudo-random samples, this is
because we can generate a quasi-random sample across and areal region
(X and Y coordinates). This in turn should reduce autocorrelation in
quadrature scheme. The weight of each quadrature point is calculated using
Dirichlet (Voronoi) Tessellation written in c++. We calculated the duel-graph
of a Delaunay triangulation. The Delaunay triangulation is constructed based
on a radial sweep algorithm.
}
\details{
The approach uses quasi-random sampling to generate a quadrature
scheme based (e.g Berman & Turner 1992; Warton & Shepard 2010;
Foster et al, 2017). The weights each quasi-random point in the quadrature
scheme is calculated using a Dirichlet tessellation (Turner 2020). To improve
computational efficiency we have rewritten the Delaunay triangulation and
Dirichlet tessellation in c++ using a sweep algorithm. The control has a
bunch of parameters you can use to tweek the ppmData object.
\itemize{
 \item{quasirandom.samples}{ integer This sets the total number of samples to consider
in the BAS step (rejection sampling). The default is 10000, which means that
10000 halton numbers are drawn and then thinned according to the inclusion
probabilities. You will need to increase the number of samples if selecting
a large number of quadrature points. The more quasirandomSamples selected the
slower the quasirandom quadrature scheme will be to generate.}
 \item{buffer.NA}{ boolean If extract from \code{\link[terra]{extract}}
 returns NA for point extract, do you want us to attempt to user buffer to
 calculate cells which are NA.}
 \item{buffer.size}{ numeric If you call 'buffer.NA' what is the range of the
 buffer in meters.}
 \item{mc.cores}{ integer The number of cores to use in the processing.
 default is parallel::detectCores()-1}
 \item{quiet}{ boolean If TRUE, do not print messages. Default is FALSE.}
}
}
\examples{
\dontrun{
library(ppmData)
library(terra)
path <- system.file("extdata", package = "ppmData")
lst <- list.files(path=path,pattern='*.tif',full.names = TRUE)
preds <- rast(lst)
window <- preds[[1]]
presences <- subset(snails,SpeciesID \%in\% "Tasmaphena sinclairi")
quad <- ppmData(npoints = 1000, presences=presences, window = window, covariates = preds)
}
}
