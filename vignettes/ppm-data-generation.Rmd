---
title: "ppm-data-generation"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{ppm-data-generation}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(qrbp)
```

For a laugh, let's generate some quasirandom background points and plot them against the presence points. Here we are using the `quasirandom_covariates` method which tries to select quasirandom points across geographic and environmental space. The other working methods are `quasirandom` which just creates quasirandom points spatially, or `grid` which creates a regular grid at a set resolution - this is every similar to the grid design proposed by Warton & Shepard 2010.

```{r,warning=FALSE,error=FALSE,message=FALSE}
library(mgcv)
library(raster)
library(randomForest)
path <- system.file("extdata", package = "qrbp")
lst <- list.files(path=path,pattern='*.tif',full.names = TRUE)
preds <- raster::stack(lst)

snails1 <- subset(snails,SpeciesID=='Victaphanta lampra')
presences <- snails1
window <- preds[[1]]
covariates <- NULL#preds
method <- 'quasirandom'
interpolation <- 'bilinear'
npoints <- 10000
resolution <- 0.0083
covariates <- preds
control <- ppmData.control()
coord <- c("X","Y")

bkgrid<- ppmData(npoints = npoints,
                 resolution = resolution,
                 presences = snails,
                 window = window,
                 covariates = covariates,
                 method = method,
                 interpolation = interpolation,
                 control=ppmData.control())

dat <- bkgrid$modelmatrix
dat <- na.omit(dat)
bkgrid$modelmatrix$wts

test <- randomForest(pres/wts ~ X + Y + max_temp_hottest_month + annual_mean_precip + annual_mean_temp,
              weights = dat$wts,
              data = dat,
              family = poisson())


fm <- gam(pres/wts ~ s(X) + s(Y) + s(max_temp_hottest_month) +
            s(annual_mean_precip) + s(annual_mean_temp),
              weights = dat$wts,
              data = dat,
              family = poisson())
plot(test)
coords <- xyFromCell(preds,1:ncell(preds))
X <- preds[[1]]
Y <- preds[[1]]
X[] <- coords[,1]
Y[] <- coords[,2]
plot(X)
plot(Y)
names(X) <- "X"
names(Y) <- "Y"
preds2 <- stack(X,Y,preds)
p <- predict(object=preds2,
             model=fm,
             type = 'response',
             const=data.frame(weights = 1))

p2 <- predict(object=preds2,
             model=test,
             type = 'response',
             const=data.frame(weights = 1))


p_cell <- p*prod(res(preds))#prod(bkgrid$parameters$newresolution)
p_cell2 <- p2*prod(res(preds))#prod(bkgrid$parameters$newresolution)
cellStats(p_cell,sum)
cellStats(p_cell2,sum)

```

Now let's plot these models.
```{r,fig.width=8,fig.height=6}
jet.colors <- colorRampPalette(rev(RColorBrewer::brewer.pal(11 , "Spectral")[-11]))
plot(p_cell,col=jet.colors(100))
points(snails1[,1:2],cex=.5,pch=16)
plot(p_cell2,col=jet.colors(100))
points(snails1[,1:2],cex=.5,pch=16)
```
